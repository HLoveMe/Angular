# Angular组件
*  组件

	```
	@Component({
		moduleId:module.id,     指定之后   导入的文件 默认加载该路径下的文件
									如果不指定  需要在app/.../a.htl 全路径
		selector:"my-input",   自定义标签名
		template:`             标签内容
			<h1></h1>
			<input [(ngModel)]="one.name"  />
			
			<ng-content></ng-content>
		`
		templateUrl:['xasas.component.html']   指定template内容
		
		host:对宿主元素 进行 事件，属性 绑定
			host:{---->HostListener，HostBinding
				"(click)":"myeventFunc($event)"
				"name":'朱子豪'，(property)
				"[class.pressed]":"isPressed属性名"; 
			}
			
			class Q{
				myeventFunc(ev:Event){}
			}
		interpolation:自定义插值 标记
		
		changeDetection:检查策略
						当输入属性改变时 如何进行更新
						ChangeDetectionStrategy.onPush不相同时 进行更新
						ChangeDetectorRef:检查对象
						
		encapsulation:封装模式 （原生 (Native)、仿真 (Emulated 默认) 和无 (None)）
			(http://origin.angular.live/docs/ts/latest/guide/component-styles.html#!#view-encapsulation)
		exportAs：string   类似   #thisF="ngForm"
		
		viewProviders:为子组件注册服务
		
		providers:[CustomServe]
									这里定义需要的服务
							
		styles:[        指定使用的css
			`
				.heroes {
				
				}
				.heroes li{
				
				}
			`
			....
			]
		styleUrls:  ['sasas.component.css']   
							指定 css 只对该组件  子组件也不能继承  
							如果需要继承等其他操作/**组件样式*/
		animations:[]  动画
		
		inputs: ['hero'],                          
		outputs: ['deleteRequest',"my-click:clickA"],
						上面两个和@input @output 不要同时使用
	})
	 export class MyInput implements 实现各种钩子接口{
	 	name:string;
	 	age:number;
	 	
		@Input() address:string;
	 	在使用该组件时需要指定的值<tag-name address="">	
		@Input( 'telephone-number' ) tel:string
		指定别名 <ta-name telephone-number="" >
		@Input() set name(name:string){this._name = xxx}
					get name(){return this._name} 
					
		@Output() sureEv = new EventEmitter<class>(); 事件导出
		@Input 在使用该组件需要的初始值
		@Output  该组件往父组件传递消息媒介
		
		@ViewChild(Class) chilCom:Class;
		@ViewChild("#name") taget:ElementRef;
		@ViewChild("#name",{read:ViewContainerRef}) taget: ViewContainerRef;
		//<A ></A>  引用子组件  (ViewChildren)
		
		@ ContentChild(class/"con") child
		// 得到占位符 <ng-content>内部子组件
		@ HostListener  监听宿主事件
		@ HostBinding 改变宿主样式
		
		constructor(
			private dataServe:CustomServe,
			private ele:ElemnetRef得到组件Document
		) { 
		    this.outEventname = new EventEmitter();
		    //this. dataServe =dataServe  不需要该赋值语句
		    //使用: this.dataServe.xxmethod()
	   }		
		
		
		
		ngOnInit(){
		//注意：在连续路由导航到某个组件时 该组件有可能被复用
				如果是使用返回那么该组件会被强制销毁
		该方法只会被执行一次
				
		}
		
	 }
	 
	 使用:
	 	<my-com1></mycom1>    永远不要再标签内插入任何内容--- 除非我们想把这些内容投影进这个组件中。

		<my-com1>
			<my-com2></my-com2>
			sasa
			sasa
		</mycom1>
	 	
	 	template:	`
	 		<ng-content></ng-content>  占位符
	 	`
组件通讯: 
		1:可以通过变量进行绑定
			@Input() name:string;
			@Input() set people(va:People){}
			生命函数 OnChanges 监听多个属性变化
		2:服务绑定
		3:绑定
			子组件事件传递给父组件
				A:
					@Output() sureEv = new EventEmitter<class>();
					super-template:
						<child-com (sureEv)="func"></child-com>
				B:
					子组件 改变父组件属性 （attr,class,property）
					@HostBinding('attr.role') role = 'button';
				    @HostBinding('class.pressed') isPressed: boolean;
			    
			    
			父组件事件传递到子组件(拥有子组件)
				A:
					1:super-template:`
						<button (click)="detailC.func（）">
						<child-com #detailC></child-com>
					`
					2:child-template:
						@HostListener("event-type"[,par]) AAF([,par]){
						
						}
					3:import { ViewChild } from '@angular/core';				>导入子组件
						>构造器@ViewChild(Component)  private childC: Component;
						>this.childC.xx()
				B:	
					@HostListener
					宿主事件监听
					 @HostListener('click', ['$event'])
					 onClick(btn: any) {}
					window document事件监听
					 @HostListener('document:click', ['$event'])
				     onClick(btn: Event) {}
				     
	```
* 组件样式

	```
		1：内联  
			template:`
				<style>
					...
				</style>
			`
		2:styles: ['h1 { font-weight: normal; }']
		3:styleUrls: ['app/hero-details.component.css']   路径相对该应用,而不是代码所处文件
		4:tempalte:
				`<link rel="stylesheet" href="app/hero-team.component.css">
					<p>....
				`
		
		
		组件指定css 只对该组件  子组件也不能继承 
		
		
		特殊选择器：
			A.  :host 选择宿主 {
				对宿主内部元素  
					tempalte:`
						这里面的元素
					`
			} 
			
			B. :host(.CC){
				宿主元素 含有class="CC vvv" 就会应用该css
				<my-com class="CC"></my-com>
			}
			
			C. :host-context(.AA) input{
					从本宿主元素 往document 查找 ，当发现某个祖先有class = "AA" 
					就在该宿主内部 执行后续选择器  
					exam:如果祖先有AA   在该组件内部的input上应用该css  可以用于主题设计
			}
			4:  /deep/ 或者 >>> 表示子组件会继承该css
				:host /deep/ h3{ 组件和所有子组件样式
				}
				:host-context(.AA) /deep/ input{
				}
				只能在仿真模式使用
	
	```
	
	
* 组件生命周期
	
	```
		import { XX} from '@angular/core';
		class com implements OnInit{
			ngOnInit([]){}
		}
	```
	|钩子 |目的和时机|
	|-------|-------|
	|ngOnChanges|当Angular（重新）设置数据绑定输入属性时响应。 该方法接受当前和上一属性值的SimpleChanges对象 当被绑定的输入属性的值发生变化时调用，首次调用一定会发生在ngOnInit之前。|
	|ngOnInit	|在Angular第一次显示数据绑定和设置指令/组件的输入属性之后，初始化指令/组件。在第一轮ngOnChanges完成之后调用，只调用一次。|
	|ngDoCheck	|检测，并在发生Angular无法或不愿意自己检测的变化时作出反应。在每个Angular变更检测周期中调用ngOnChanges和ngOnInit之后。|
|ngAfterContentInit	|当把内容投影进组件之后调用。第一次NgDoCheck之后调用，只调用一次。只适用于组件。|
|ngAfterContentChecked	|每次完成被投影组件内容的变更检测之后调用。ngAfterContentInit和每次NgDoCheck之后调用只适合组件。|
|ngAfterViewInit	|初始化完组件视图及其子视图之后调用。第一次ngAfterContentChecked之后调用，只调用一次。只适合组件。|
|ngAfterViewChecked	|每次做完组件视图和子视图的变更检测之后调用。ngAfterViewInit和每次ngAfterContentChecked之后调用。只适合组件。|
|ngOnDestroy	|当Angular每次销毁指令/组件之前调用并清扫。 这儿反订阅可观察对象和分离事件处理器，以防内存泄漏。在Angular销毁指令/组件之前调用。|

	
		* AfterView 关心的是组件和其子组件的更新
		* AfterContent关心的内容投影  <ng-content>更新

		
* 动态组件

	```
	模板生成后 内容可以随内容改变
		组件对象	
			@Directive({selector:"[host]"})
			export class AdsContainer{
				  constructor(public container:ViewContainerRef){}
			}
			服务import {ComponentFactoryResolver} from '@angular/core';
			 创建工厂
			 factory = this.Resolver.resolveComponentFactory(ComponentOne)
			 清除现有组件
			 container.clear()
			 创建新组件并添加 
			 ComponentRef = container.createComponent(factory)
			 
			 ComponentRef.instance 组件对象	
			 	操作组件对象				
			 entryComponents:[需要动态加载组件]
	见 实例
	```